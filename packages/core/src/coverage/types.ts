/**
 * Coverage types - Unified Gap model for story completeness and narrative gaps.
 *
 * The Gap model unifies:
 * - Rule violations (structural issues)
 * - Derived checks (missing elements)
 * - Open Questions (narrative gaps needing creative input)
 *
 * This provides a single abstraction for the Coverage tab pyramid and gap resolution.
 */

// =============================================================================
// Gap Types
// =============================================================================

/**
 * Gap type indicates the nature of the gap.
 * - 'structural': Rule violation or completeness issue, fixable with patches
 * - 'narrative': Creative/planning gap needing human/AI decision or generation
 */
export type GapType = 'structural' | 'narrative';

/**
 * Gap tier corresponds to the pyramid visualization levels.
 * Ordered from top (most abstract) to bottom (most concrete).
 */
export type GapTier =
  | 'premise' // Top: Premise node (0-1)
  | 'foundations' // Setting, GenreTone, Conflict, Theme, Motif, Character
  | 'structure' // Beat nodes (15 STC beats)
  | 'plotPoints' // PlotPoint nodes
  | 'scenes'; // Scene nodes

/**
 * Gap severity determines visual treatment and priority.
 * - 'blocker': From hard rules, should be fixed
 * - 'warn': From soft rules, recommended to fix
 * - 'info': Informational, optional to address
 */
export type GapSeverity = 'blocker' | 'warn' | 'info';

/**
 * Source of the gap.
 * - 'rule-engine': Generated from lint rule violations
 * - 'derived': Generated from coverage-specific checks (missing beats, foundations)
 * - 'user': Manually created by user
 * - 'extractor': Generated by AI extractor during import
 * - 'import': Generated during story import
 */
export type GapSource = 'rule-engine' | 'derived' | 'user' | 'extractor' | 'import';

/**
 * Gap status for tracking resolution.
 * - 'open': Needs attention
 * - 'in_progress': Being worked on
 * - 'resolved': Has been addressed
 */
export type GapStatus = 'open' | 'in_progress' | 'resolved';

/**
 * Gap domain indicates the narrative area the gap relates to.
 * Used for filtering and clustering related gaps.
 */
export type GapDomain =
  | 'STRUCTURE'
  | 'SCENE'
  | 'CHARACTER'
  | 'CONFLICT'
  | 'THEME_MOTIF';

/**
 * Gap phase indicates when this gap is most relevant.
 * Narrative gaps are phase-gated to surface at appropriate times.
 */
export type GapPhase = 'OUTLINE' | 'DRAFT' | 'REVISION';

// =============================================================================
// Gap Interface
// =============================================================================

/**
 * A single gap representing something missing, incomplete, or undecided in the story.
 *
 * Gaps unify:
 * - Structural issues from rule violations (type: 'structural')
 * - Narrative questions needing creative input (type: 'narrative')
 */
export interface Gap {
  /** Unique identifier for this gap */
  id: string;

  /** Type of gap: structural (fixable with patches) or narrative (needs creative input) */
  type: GapType;

  /** Which tier of the pyramid this gap belongs to */
  tier: GapTier;

  /** Short title for display */
  title: string;

  /** Detailed description explaining the gap */
  description: string;

  /** References to related nodes and edges */
  scopeRefs: {
    nodeIds?: string[];
    edgeIds?: string[];
  };

  /** Severity level */
  severity: GapSeverity;

  /** Where this gap came from */
  source: GapSource;

  /** Current status */
  status: GapStatus;

  // -------------------------------------------------------------------------
  // Optional fields for narrative gaps (from Open Questions system)
  // -------------------------------------------------------------------------

  /** Phase when this gap is most relevant (for narrative gaps) */
  phase?: GapPhase;

  /** Domain this gap relates to (for filtering/clustering) */
  domain?: GapDomain;

  /** Key for grouping related gaps (for cluster generation) */
  groupKey?: string;

  // -------------------------------------------------------------------------
  // Resolution tracking
  // -------------------------------------------------------------------------

  /** Other gap IDs that must be resolved before this one */
  dependencies?: string[];

  /** Information about how this gap was resolved */
  resolvedBy?: {
    /** Story version where resolution was applied */
    versionId: string;
    /** Patch ID that resolved this gap */
    patchId?: string;
    /** When the gap was resolved */
    timestamp: string;
  };
}

// =============================================================================
// Tier Summary
// =============================================================================

/**
 * Summary of coverage for a single tier.
 */
export interface TierSummary {
  /** Tier identifier */
  tier: GapTier;
  /** Human-readable label */
  label: string;
  /** Number of items that are "covered" (complete) */
  covered: number;
  /** Total expected items */
  total: number;
  /** Percentage covered (0-100) */
  percent: number;
}

// =============================================================================
// Coverage Response
// =============================================================================

/**
 * Complete coverage response returned by the API.
 */
export interface CoverageResponse {
  /** Summary for each tier */
  summary: TierSummary[];
  /** All gaps found */
  gaps: Gap[];
}

// =============================================================================
// Tier Configuration
// =============================================================================

/**
 * Configuration for each tier.
 */
export interface TierConfig {
  label: string;
  order: number;
}

/**
 * Tier configuration lookup.
 */
export const TIER_CONFIG: Record<GapTier, TierConfig> = {
  premise: { label: 'Premise', order: 1 },
  foundations: { label: 'Foundations', order: 2 },
  structure: { label: 'Structure', order: 3 },
  plotPoints: { label: 'Plot Points', order: 4 },
  scenes: { label: 'Scenes', order: 5 },
};

/**
 * Ordered list of tiers from top to bottom.
 */
export const TIER_ORDER: GapTier[] = [
  'premise',
  'foundations',
  'structure',
  'plotPoints',
  'scenes',
];

// =============================================================================
// Narrative Gap Mapping (from Open Questions)
// =============================================================================

/**
 * Configuration for mapping OQ types to Gap properties.
 */
export interface NarrativeGapConfig {
  tier: GapTier;
  type: GapType;
  domain: GapDomain;
  defaultSeverity: GapSeverity;
  phase: GapPhase;
}

/**
 * Narrative gap type identifiers (formerly OpenQuestion types).
 */
export type NarrativeGapType =
  // Structure domain
  | 'BeatUnrealized'
  | 'ActImbalance'
  | 'SceneUnplaced'
  // Scene domain
  | 'SceneNeedsOverview'
  | 'SceneHasNoCast'
  | 'SceneNeedsLocation'
  // Character domain
  | 'CharacterUnderspecified'
  | 'MissingCharacterArc'
  | 'ArcUngrounded'
  // Conflict domain
  | 'ConflictNeedsParties'
  | 'ConflictNeedsManifestation'
  // Theme/Motif domain
  | 'ThemeUngrounded'
  | 'MotifUngrounded';

/**
 * Mapping from narrative gap types to their configuration.
 * Used when deriving narrative gaps from graph state.
 */
export const NARRATIVE_GAP_CONFIG: Record<NarrativeGapType, NarrativeGapConfig> = {
  // STRUCTURE domain
  BeatUnrealized: {
    tier: 'structure',
    type: 'narrative',
    domain: 'STRUCTURE',
    defaultSeverity: 'warn',
    phase: 'OUTLINE',
  },
  ActImbalance: {
    tier: 'structure',
    type: 'narrative',
    domain: 'STRUCTURE',
    defaultSeverity: 'warn',
    phase: 'OUTLINE',
  },
  SceneUnplaced: {
    tier: 'scenes',
    type: 'structural',
    domain: 'STRUCTURE',
    defaultSeverity: 'blocker',
    phase: 'OUTLINE',
  },

  // SCENE domain
  SceneNeedsOverview: {
    tier: 'scenes',
    type: 'narrative',
    domain: 'SCENE',
    defaultSeverity: 'blocker',
    phase: 'DRAFT',
  },
  SceneHasNoCast: {
    tier: 'scenes',
    type: 'narrative',
    domain: 'SCENE',
    defaultSeverity: 'warn',
    phase: 'DRAFT',
  },
  SceneNeedsLocation: {
    tier: 'scenes',
    type: 'narrative',
    domain: 'SCENE',
    defaultSeverity: 'warn',
    phase: 'DRAFT',
  },

  // CHARACTER domain
  CharacterUnderspecified: {
    tier: 'foundations',
    type: 'narrative',
    domain: 'CHARACTER',
    defaultSeverity: 'info',
    phase: 'OUTLINE',
  },
  MissingCharacterArc: {
    tier: 'foundations',
    type: 'narrative',
    domain: 'CHARACTER',
    defaultSeverity: 'warn',
    phase: 'DRAFT',
  },
  ArcUngrounded: {
    tier: 'foundations',
    type: 'narrative',
    domain: 'CHARACTER',
    defaultSeverity: 'info',
    phase: 'REVISION',
  },

  // CONFLICT domain
  ConflictNeedsParties: {
    tier: 'foundations',
    type: 'narrative',
    domain: 'CONFLICT',
    defaultSeverity: 'warn',
    phase: 'DRAFT',
  },
  ConflictNeedsManifestation: {
    tier: 'foundations',
    type: 'narrative',
    domain: 'CONFLICT',
    defaultSeverity: 'warn',
    phase: 'DRAFT',
  },

  // THEME_MOTIF domain
  ThemeUngrounded: {
    tier: 'foundations',
    type: 'narrative',
    domain: 'THEME_MOTIF',
    defaultSeverity: 'info',
    phase: 'REVISION',
  },
  MotifUngrounded: {
    tier: 'foundations',
    type: 'narrative',
    domain: 'THEME_MOTIF',
    defaultSeverity: 'info',
    phase: 'REVISION',
  },
};

/**
 * All narrative gap types.
 */
export const NARRATIVE_GAP_TYPES: NarrativeGapType[] = [
  'BeatUnrealized',
  'ActImbalance',
  'SceneUnplaced',
  'SceneNeedsOverview',
  'SceneHasNoCast',
  'SceneNeedsLocation',
  'CharacterUnderspecified',
  'MissingCharacterArc',
  'ArcUngrounded',
  'ConflictNeedsParties',
  'ConflictNeedsManifestation',
  'ThemeUngrounded',
  'MotifUngrounded',
];

/**
 * All gap domains.
 */
export const GAP_DOMAINS: GapDomain[] = [
  'STRUCTURE',
  'SCENE',
  'CHARACTER',
  'CONFLICT',
  'THEME_MOTIF',
];

/**
 * All gap phases.
 */
export const GAP_PHASES: GapPhase[] = ['OUTLINE', 'DRAFT', 'REVISION'];
